-<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>METAR Dashboard</title>
  <style>
    :root {
      --bg: #fafafa;
      --accent: #0d3b66;
      --text: #05386b;
      --text-muted: #5c677d;
      --row1: #ffffff;
      --row2: #e0e4e8;
      --border: #c4ccd6;
      --warn: #d62828;
      --sigwx: #f77f00;
      --recent: #ffd54f; /* highlight for recent updates (light theme) */
    }

    body.dark {
      --bg: #121212;
      --accent: #03dac6;
      --text: #e0e0e0;
      --text-muted: #888888;
      --row1: #1f1f1f;
      --row2: #2a2a2a;
      --border: #333333;
      --warn: #ff6b6b;
      --sigwx: #ffd166;
      --recent: #7a5cff; /* highlight for recent updates (dark theme) */
    }

    body, table, th, td {
      transition: background 0.3s, color 0.3s, border-color 0.3s;
    }

    html {
      font-size: 18px;
    }

    body {
      margin: 0;
      padding: 2rem;
      font-family: "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      position: relative;
    }

    #theme-toggle {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.6rem;
      color: var(--text);
      padding: 0.2rem;
    }

    #refresh-btn {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
    }

    h1 {
      text-align: center;
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      color: var(--accent);
    }

    #updated {
      text-align: center;
      font-size: 1rem;
      color: var(--text-muted);
      margin-bottom: 1.5rem;
    }

    .table-container {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0 auto;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      background: var(--row1);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      min-width: 900px;
    }

    thead th {
      background: var(--accent);
      color: #fff;
      padding: 0.8rem;
      font-size: 1.5rem;
      text-transform: uppercase;
      border-bottom: 2px solid var(--border);
    }

    th, td {
      padding: 0.8rem;
      text-align: center;
      font-size: 1.4rem;
      user-select: none;
      border-bottom: 1px solid var(--border);
    }

    th:not(:last-child),
    td:not(:last-child) {
      border-right: 1px solid var(--border);
    }

    tbody tr:nth-child(odd) {
      background: var(--row2);
    }

    tbody tr:nth-child(even) {
      background: var(--row1);
    }

    td:hover {
      background: var(--row2);
    }

    .station-cell {
      text-align: left;
      padding-left: 1.2rem;
    }

    .station-cell .code {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
    }

    .raw-row .raw-data {
      background: var(--row1);
      color: var(--text-muted);
      font-family: "Courier New", monospace;
      font-size: 1.1rem; /* bigger */
      text-align: left;
      padding: 1rem; /* more padding */
      border-top: 1px solid var(--border);
      cursor: default;
      user-select: text;
      white-space: pre-wrap; /* preserve newlines for TNCM two-line display */
    }

    .flash {
      animation: flashTime 0.5s ease-in-out;
    }
    @keyframes flashTime {
      0%   { background: var(--row1); color: var(--text); }
      50%  { background: var(--accent); color: #fff; }
      100% { background: var(--row1); color: var(--text); }
    }

    /* Highlighting */
    .wx-bad { background: var(--warn); color: #fff; font-weight: bold; }
    .wx-sig { background: var(--sigwx); color: #000; font-weight: bold; }

    /* Recent update persistent highlight (30 minutes) */
    .recent {
      background: var(--recent) !important;
      color: #000 !important;
      font-weight: 700;
      border-radius: 6px;
      padding: 0.3rem;
    }

    /* Make the time cell stand out a bit when recent in dark mode text color */
    body.dark .recent { color: #fff !important; }
  </style>
</head>
<body>

  <button id="refresh-btn">âŸ³ Refresh</button>
  <button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
  <h1>Latest METARs</h1>
  <div id="updated">Last Updated: â€”</div>

  <div class="table-container">
    <table>
      <thead>
        <tr>
          <th scope="col">Station</th>
          <th scope="col">Time (Z)</th>
          <th scope="col">Wind</th>
          <th scope="col">Vis</th>
          <th scope="col">Weather</th>
          <th scope="col">Clouds</th>
          <th scope="col">T/TDP (Â°C)</th>
          <th scope="col">Pressure (hPa - inHg)</th>
        </tr>
      </thead>
      <tbody id="metar-body">
        <tr><td colspan="8">Loadingâ€¦</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    const PROXY    = 'https://api.allorigins.win/raw?url=';
    const RAW_URLS = {
      TNCA: 'https://tgftp.nws.noaa.gov/data/raw/sa/sanu31.tnca..txt',
      TNCB: 'https://tgftp.nws.noaa.gov/data/raw/sa/sadc31.ehdb..txt',
      TNCC: 'https://tgftp.nws.noaa.gov/data/raw/sa/saca31.tncc..txt',
      TNCM: 'https://tgftp.nws.noaa.gov/data/raw/sa/samn31.tncm..txt',
      SVMI: 'https://tgftp.nws.noaa.gov/data/raw/sa/savn22.svmi..txt',
      SVVA: 'https://tgftp.nws.noaa.gov/data/raw/sa/savn31.svva..txt'
    };
    const ORDER      = ['TNCA','TNCB','TNCC','TNCM','SVMI','SVVA'];
    const REFRESH_MS = 20 * 1000;
    const prevTimes  = {};

    // how long (ms) to keep the "recent" color after a detected update
    const RECENT_MS = 30 * 60 * 1000; // 30 minutes

    // store expiration timestamps (ms since epoch) for each station's recent highlight
    let recentExpires = {};

    document.addEventListener('DOMContentLoaded', () => {
      const btn   = document.getElementById('theme-toggle');
      const saved = localStorage.getItem('theme');
      if (saved === 'dark') document.body.classList.add('dark');
      updateIcon();

      // load persisted recentExpires (and purge expired)
      loadRecentExpires();

      btn.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        localStorage.setItem('theme',
          document.body.classList.contains('dark') ? 'dark' : 'light'
        );
        updateIcon();
      });
      document.getElementById('refresh-btn').addEventListener('click', fetchAndRender);
      fetchAndRender();
      setInterval(fetchAndRender, REFRESH_MS);
    });

    function updateIcon() {
      document.getElementById('theme-toggle').textContent =
        document.body.classList.contains('dark') ? 'â˜€ï¸' : 'ðŸŒ™';
    }

    function loadRecentExpires() {
      try {
        const raw = localStorage.getItem('recentExpires');
        if (!raw) return;
        const parsed = JSON.parse(raw);
        const now = Date.now();
        for (const k in parsed) {
          const v = Number(parsed[k]);
          if (!isFinite(v)) continue;
          if (v > now) recentExpires[k] = v;
        }
        // persist cleaned version back
        saveRecentExpires();
      } catch (e) {
        console.warn('Failed loading recentExpires', e);
        recentExpires = {};
      }
    }

    function saveRecentExpires() {
      try {
        localStorage.setItem('recentExpires', JSON.stringify(recentExpires));
      } catch (e) {
        // ignore storage failures
      }
    }

    async function fetchAndRender() {
      const tbody = document.getElementById('metar-body');
      tbody.innerHTML = '';
      for (const code of ORDER) {
        let r;
        let originalTxt = '';
        try {
          const res = await fetch(PROXY + encodeURIComponent(RAW_URLS[code]));
          if (!res.ok) throw new Error(res.statusText);
          originalTxt = await res.text();
          r = parseMETAR(originalTxt);
        } catch (e) {
          r = { station: code, time: 'â€”', wind: 'â€”', vis: 'â€”', weather: 'â€”', clouds: 'â€”', temp: 'â€”', dew: 'â€”', pressure: 'â€”', raw: 'Error fetching', rawSource2: null };
        }

        // For TNCM specifically: if there's a Q#### in the source, prefer that and format "1011 - 29.85"
        if (r.station === 'TNCM' && originalTxt) {
          const m = originalTxt.match(/Q(\d{4})/i);
          if (m) {
            const hpa = Number(m[1]);
            if (isFinite(hpa) && hpa > 0) {
              const inHg = (hpa * 0.02953).toFixed(2);
              r.pressure = `${hpa} - ${inHg}`; // exactly "1011 - 29.85" style as requested
            }
          }
        }

        const oldTime = prevTimes[r.station];
        const isNew   = oldTime !== undefined && oldTime !== r.time;
        prevTimes[r.station] = r.time;

        // If change detected, set recent highlight expiry
        if (isNew) {
          recentExpires[r.station] = Date.now() + RECENT_MS;
          saveRecentExpires();
        }

        // purge expired entries on each render (keeps localStorage tidy)
        const now = Date.now();
        for (const s in recentExpires) {
          if (recentExpires[s] <= now) delete recentExpires[s];
        }
        saveRecentExpires();

        const tr = document.createElement('tr');
        const td0 = document.createElement('td');
        td0.classList.add('station-cell');
        td0.innerHTML = `<div class="code">${r.station}</div>`;
        tr.appendChild(td0);

        [r.time, r.wind, r.vis, r.weather, r.clouds,
         `${r.temp}/${r.dew}`, r.pressure
        ].forEach((val, idx) => {
          const td = document.createElement('td');
          td.textContent = val || 'â€”';

          if (idx === 3 && val !== 'â€”') {
            if (/TS|FG|SN|GR|SS/.test(val)) td.classList.add('wx-bad');
            else if (/RA|DZ|SH|BR/.test(val)) td.classList.add('wx-sig');
          }

          // Time cell: index 0. Add flash and persistent recent class when appropriate.
          if (idx === 0 && isNew) {
            td.classList.add('flash');
            setTimeout(() => td.classList.remove('flash'), 600);
          }

          if (idx === 0 && recentExpires[r.station] && Date.now() < recentExpires[r.station]) {
            td.classList.add('recent');
            const exp = new Date(recentExpires[r.station]);
            td.title = `Highlighted until: ${exp.toLocaleString()}`;
          }

          // Also set the UTC->local hover title when the time looks like ddhhmmZ
          if (idx === 0 && r.time.match(/^\d{6}Z$/)) {
            const dd = +r.time.slice(0,2);
            const hh = r.time.slice(2,4);
            const mm = r.time.slice(4,6);
            const utc = new Date();
            // keep this month/year as now to avoid weird wrap issues
            const nowDate = new Date();
            utc.setUTCFullYear(nowDate.getUTCFullYear());
            utc.setUTCMonth(nowDate.getUTCMonth());
            utc.setUTCDate(dd);
            utc.setUTCHours(+hh, +mm, 0, 0);
            const prevTitle = td.title ? td.title + ' â€” ' : '';
            td.title = prevTitle + 'Local: ' + utc.toLocaleTimeString('en-US', { timeZone: 'America/Curacao', hour12: false });
          }

          td.addEventListener('dblclick', () => copyText(val, td));
          tr.appendChild(td);
        });

        tbody.appendChild(tr);

        // RAW row: for TNCM show the two source lines (METAR line + next line if present)
        const trRaw = document.createElement('tr');
        trRaw.classList.add('raw-row');
        const tdRaw = document.createElement('td');
        tdRaw.colSpan = 8;
        tdRaw.classList.add('raw-data');

        if (r.station === 'TNCM' && r.rawSource2) {
          // preserve newlines in display; textContent + white-space: pre-wrap in CSS
          tdRaw.textContent = r.rawSource2;
        } else {
          tdRaw.textContent = r.raw;
        }

        trRaw.appendChild(tdRaw);
        tbody.appendChild(trRaw);
      }

      // Update the Last Updated area with both Local (America/Curacao) and UTC times
      const now = new Date();
      const localStr = now.toLocaleTimeString('en-US', { hour12: false, timeZone: 'America/Curacao' });
      const utcStr   = now.toLocaleTimeString('en-US', { hour12: false, timeZone: 'UTC' });
      document.getElementById('updated').textContent =
        `Last Updated â€” Local (America/Curacao): ${localStr} â€” UTC: ${utcStr}`;
    }

    function parseMETAR(txt) {
      // txt is the full fetched text. We'll extract:
      // - a cleaned single-line 'raw' (same as before)
      // - rawSource2: the METAR line and the next source line (if present) for TNCM use
      const linesAll = txt.split('\n').map(l => l.replace(/\r/g, '').trim());
      // find index of the line containing 'METAR'
      let metarIdx = -1;
      for (let i = 0; i < linesAll.length; i++) {
        if (/\bMETAR\b/i.test(linesAll[i])) { metarIdx = i; break; }
      }

      // build rawSource2: METAR line + next line if exists
      let rawSource2 = null;
      if (metarIdx >= 0) {
        const a = linesAll[metarIdx] || '';
        const b = (linesAll[metarIdx + 1] || '').trim();
        rawSource2 = b ? (a + '\n' + b) : a;
      } else {
        // fallback: first two non-empty lines
        const nonEmpty = linesAll.filter(Boolean);
        rawSource2 = nonEmpty.slice(0,2).join('\n') || (nonEmpty[0] || '');
      }

      // previous single-line extraction logic (clean out RMK and trailing =) to show a concise single-line raw
      let line = linesAll.find(l => /\bMETAR\b/i.test(l)) || linesAll[0] || '';
      line = line.replace(/RMK.*/i, '').replace(/=$/, '').trim();
      const raw = line;

      let toks = raw.split(/\s+/);

      let i = toks.indexOf('METAR') + 1;
      let station = toks[i++] || '';
      let time    = toks[i++] || '';

      // skip COR if present
      if (toks[i] === 'COR') i++;

      if (toks[i] === 'AUTO') i++;

      // WIND
      let wind = 'â€”';
      if (toks[i]?.endsWith('KT')) {
        wind = toks[i].replace(/G\d{2}(?=KT)/, '');
        i++;
      }
      if (/^\d{3}V\d{3}$/.test(toks[i])) i++;

      // VIS
      let vis = 'â€”';
      if (toks[i] === 'CAVOK') {
        vis = 'CAVOK';
        i++;
      } else if (/^\d{4}(?:[NSEW]{1,2})?$/.test(toks[i])) {
        const visPieces = [];
        while (toks[i] && /^\d{4}(?:[NSEW]{1,2})?$/.test(toks[i])) {
          visPieces.push(toks[i++]);
        }
        vis = visPieces.join(' ');
      }

      // WEATHER
      const wx = [];
      while (
        toks[i] &&
        !isCloud(toks[i]) &&
        !/^\d+\/-?\d+$/.test(toks[i])
      ) {
        wx.push(toks[i++]);
      }
      const weather = wx.join(' ') || 'â€”';

      // CLOUDS
      const cl = [];
      while (toks[i] && isCloud(toks[i])) {
        cl.push(toks[i++]);
      }
      const clouds = cl.join(' ') || 'CLR';

      // TEMP/DEW
      const td = toks[i++] || 'M00/M00';
      const [temp, dew] = td.split('/').map(v => v.replace(/^M/, '-'));

      // PRESSURE (initial detection; may be overridden for TNCM)
      let pressure = 'â€”';
      if (/^Q\d{4}$/.test(toks[i])) {
        const hpa = +toks[i].slice(1);
        const inHg = (hpa * 0.02953).toFixed(2);
        pressure = `${hpa} â€“ ${inHg}`; i++;
      } else if (/^A\d{4}$/.test(toks[i])) {
        const inHgVal = +toks[i].slice(1) / 100;
        const hpaVal  = Math.round(inHgVal / 0.02953);
        pressure = `${hpaVal} â€“ ${inHgVal.toFixed(2)}`; i++;
      }

      return { station, time, wind, vis, weather, clouds, temp, dew, pressure, raw, rawSource2 };
    }

    function isCloud(tok) {
      return /^(FEW|SCT|BKN|OVC)(\d{3}|\/\/\/)(CB|TCU)?$/.test(tok) || tok === 'CAVOK';
    }

    function copyText(txt, el) {
      navigator.clipboard.writeText(txt)
        .then(() => {
          el.classList.add('flash');
          setTimeout(() => el.classList.remove('flash'), 400);
        });
    }
  </script>

</body>
</html>
